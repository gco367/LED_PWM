/* Library inclusion. */
#include <xc.h>

/* Type definition. */
#ifndef uint16_t
typedef unsigned int uint16_t;
#define uint16_t uint16_t
#define UINT16_MAX (65535U)
#endif

/* Configuration bits. */
#pragma config FOSC     = INTOSC_HS
#pragma config BOR      = ON
#pragma config BORV     = 3
#pragma config WDT      = OFF
#pragma config MCLRE    = ON
#pragma config PBADEN   = OFF
#pragma config STVREN   = ON
#pragma config LVP      = OFF

/* Function prototypes. */

/**
 * Configures TMR2 and CCP module for PWM operation.
 */
void pwm_config(void);

/**
 * Configures the A/D converter module.
 */
void adc_config(void);

/**
 * Reads channel 0 of the ADC module.
 * @return the voltage value of the potentiometer (AN0) read by the ADC module.
 */
uint16_t adc_read(void);

/**
 * Uses for loops to create delays.
 * @param delay_value the delay time, in ms.
 */
void ms_delay(uint16_t delay_value);

/**
 * Changes the duty cycle of the PWM pulse generated by CCP1.
 * @param duty_cycle the new duty cycle value.
 */
void change_duty_cycle(uint16_t duty_cycle);

void main(void){
    
    /* Sets internal oscillator (8 MHz) as the CPU clock source. */
    OSCCON = 0x72;
    
    /* Configures PWM module. */
    pwm_config();
    
    /* Configures ADC module. */
    adc_config();
    
    /* Enables TMR2 by writing to T2CON and starts generating the PWM signal. */
    T2CONbits.TMR2ON = 1;
    
    /* Holds the voltage value of the potentiometer read by the ADC module. */
    uint16_t pot_voltage;
    
    /* Main loop. */
    while(1){
        /* Waits for 10 ms. */
        ms_delay(10);
        /* Reads potentiometer. */
        pot_voltage = adc_read();
        /* Changes duty cycle value. */
        change_duty_cycle(pot_voltage);
    }
    
    return ;
}

void pwm_config(void){
    
    /* Timer2 Configuration:
     * The CCP module on PWM mode uses Timer2 (TMR2),
     * so it is necessary to configure the TMR2 prescaler value.
     * A prescaler is used to reduce the frequency by which
     * the counter of the timer increases. The Prescaler value
     * of TMR2 is set using the T2CKPS1 and T2CKPS0 bits.
     * Here, the prescaler value is set to 1. */
    T2CONbits.T2CKPS = 00;
    
    /* Clears TMR2 counter. */
    TMR2 = 0;
    
    /* Establish the PWM period by writing to the PR2 register.
     * The PR2 value is calculated using the following equation:
     * PR2 = Fosc / (Fpwm * 4 * Timer2Prescale) - 1
     * For a PWM frequency Fpwm = 10 kHz, with a Fosc = 8 MHz
     * and TMR2 prescaler value = 1, PR2 = 199. */
    PR2 = 199;
    
    /* Establish the PWM duty cycle by writing to CCPR1L and CCP1CON.
     * The PWM duty cycle is specified by writing to the CCPR1L register
     * and to the CCP1CON<5:4> bits. The CCPRxL contains the 8 MSBs and
     * CCPxCON<5:4> contains the 2 LSBs.
     * Here, duty cycle is set to 20%. */
    CCPR1L = 40;
    
    /* Makes the CCP1 pin an output by clearing the TRIS bit. */
    TRISCbits.RC2 = 0;
    
    /* Configures the CCP module for PWM operation. */
    CCP1CON = 0x0C;
    
    /* Now the PIC is ready to generate the PWM pulse by enabling Timer2. */
}

void adc_config(void){
    
    /* Defines AN0 as an analog input. */
    ADCON1bits.PCFG = 0b1110;
    TRISAbits.TRISA0 = 1;
    /* Defines Vss as Vref- source. */
    ADCON1bits.VCFG1 = 0;
    /* Defines Vdd as Vref+ source. */
    ADCON1bits.VCFG0 = 0;
    /* Defines clock conversion... */
    ADCON2 = 0b00001110;
    /* ... and result format. */
    ADCON2bits.ADFM = 1;
    /* Enables A/D module. */
    ADCON0=0x01;
    
}

uint16_t adc_read(void){
    
    uint16_t result;
    
    /* Selects channel 0 for A/D conversion. */
    ADCON0bits.CHS = 0;
    /* Starts A/D conversion. */
    ADCON0bits.GO = 1;
    /* Waits for conversion. */
    while(ADCON0bits.NOT_DONE);

    /* Saves conversion result. */
    result = ADRESH;
    result <<= 8;
    result |= ADRESL;

    return result;
}

void ms_delay(unsigned int delay_value){
    
    unsigned int i,j;
    /* Delay of "delay_value" ms for Fosc = 8 MHz. */
    for(i = 0; i <= delay_value; i++)
        for(j = 0; j < 165; j++) ;
    
 }

void change_duty_cycle(uint16_t duty_cycle){
    
    /* Writes new value on CCP1 to change the PWM's duty cycle. */
    CCP1CONbits.DC1B = (duty_cycle & 0b00000011);
    CCPR1L = ((duty_cycle & 0b1111111100) >> 2);
    
}