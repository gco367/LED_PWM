/* Library inclusion. */
#include <xc.h>

/* Type definition. */
#ifndef uint16_t
typedef unsigned int uint16_t;
#define uint16_t uint16_t
#define UINT16_MAX (65535U)
#endif

/* Configuration bits. */
#pragma config FOSC     = INTOSC_HS
#pragma config BOR      = ON
#pragma config BORV     = 3
#pragma config WDT      = OFF
#pragma config MCLRE    = ON
#pragma config PBADEN   = OFF
#pragma config STVREN   = ON
#pragma config LVP      = OFF

/* Function prototypes. */

/**
 * Configures TMR1 to generate an interruption every 1 ms.
 */
void tmr1_config(void);

/**
 * Configures TMR2 and CCP module for PWM operation.
 */
void pwm_config(void);

/**
 * Configures the A/D converter module.
 */
void adc_config(void);

/**
 * Reads channel 0 of the ADC module.
 * @return the voltage value of the potentiometer (AN0) read by the ADC module.
 */
uint16_t adc_read(void);

/**
 * Changes the duty cycle of the PWM pulse generated by CCP1.
 * @param duty_cycle the new duty cycle value.
 */
void change_duty_cycle(uint16_t duty_cycle);

/**
 * Interruption routine. Runs every 1 ms.
 */
void interrupt ISR(void);

/* Global variable. */

/* Holds the voltage value of the potentiometer read by the ADC module. */
uint16_t pot_voltage;

void main(void){
    
    /* Set internal oscillator (8 MHz) as the CPU clock source. */
    OSCCON = 0x72;
    
    /* Configure TMR1 to create an interruption every 1 ms. */
    tmr1_config();
    
    /* Configure PWM module. */
    pwm_config();
    
    /* Configure ADC module. */
    adc_config();
    
    /* Enable TMR2 by writing to T2CON. Start generating the PWM signal. */
    T2CONbits.TMR2ON = 1;
    
    /* Enable peripheral and global interruptions. */
    INTCONbits.PEIE = 1;
    INTCONbits.GIE = 1;
    
    /* Start TMR1. */
    T1CONbits.TMR1ON = 1;
    
    /* Wait for interruption. */
    while(1) ;
    
    return ;
}

/**
 * Configures TMR1 to generate an interruption every 1 ms.
 */
void tmr1_config(void){
    
    /* Enable 16-Bit Read/Write mode. */
    T1CONbits.RD16 = 1;
    /* Use internal clock as clock source for TMR1. */
    T1CONbits.TMR1CS = 0;
    T1CONbits.T1RUN = 0;
    T1CONbits.T1OSCEN = 0;
    /* 1:1 Prescale */
    T1CONbits.T1CKPS = 0;
    /* Load value to generate one interruption every 1 ms. */
    TMR1 = 0xF856;
    /* Clear overflow flag. */
    PIR1bits.TMR1IF = 0;
    /* Enable TMR1 interruption. */
    PIE1bits.TMR1IE = 1;
    
}

/**
 * Configures TMR2 and CCP module for PWM operation.
 */
void pwm_config(void){
    
    /* Timer2 Configuration:
     * The CCP module on PWM mode uses Timer2 (TMR2),
     * so it is necessary to configure the TMR2 prescaler value.
     * A prescaler is used to reduce the frequency by which
     * the counter of the timer increases. The Prescaler value
     * of TMR2 is set using the T2CKPS1 and T2CKPS0 bits.
     * Here, the prescaler value is set to 1. */
    T2CONbits.T2CKPS = 00;
    
    /* Clear TMR2 counter. */
    TMR2 = 0;
    
    /* Establish the PWM period by writing to the PR2 register.
     * The PR2 value is calculated using the following equation:
     * PR2 = Fosc / (Fpwm * 4 * Timer2Prescale) - 1
     * For a PWM frequency Fpwm = 10 kHz, with a Fosc = 8 MHz
     * and TMR2 prescaler value = 1, PR2 = 199. */
    PR2 = 199;
    
    /* Establish the PWM duty cycle by writing to CCPR1L and CCP1CON.
     * The PWM duty cycle is specified by writing to the CCPR1L register
     * and to the CCP1CON<5:4> bits. The CCPRxL contains the 8 MSBs and
     * CCPxCON<5:4> contains the 2 LSBs.
     * Here, duty cycle is set to 20%. */
    CCPR1L = 40;
    
    /* Set the CCP1 pin as an output by clearing the TRIS bit. */
    TRISCbits.RC2 = 0;
    
    /* Configure the CCP module for PWM operation. */
    CCP1CON = 0x0C;
    
    /* Now the PIC is ready to generate the PWM pulse by enabling Timer2. */
}

/**
 * Configures the A/D converter module.
 */
void adc_config(void){
    
    /* Set AN0 as an analog input. */
    ADCON1bits.PCFG = 0b1110;
    TRISAbits.TRISA0 = 1;
    /* Set Vss as Vref- source. */
    ADCON1bits.VCFG1 = 0;
    /* Set Vdd as Vref+ source. */
    ADCON1bits.VCFG0 = 0;
    /* Set clock conversion... */
    ADCON2 = 0b00001110;
    /* ... and result format. */
    ADCON2bits.ADFM = 1;
    /* Enable A/D module. */
    ADCON0=0x01;
    
}

/**
 * Reads channel 0 of the ADC module.
 * @return the voltage value of the potentiometer (AN0) read by the ADC module.
 */
uint16_t adc_read(void){
    
    uint16_t result;
    
    /* Select channel 0 for A/D conversion. */
    ADCON0bits.CHS = 0;
    /* Start A/D conversion. */
    ADCON0bits.GO = 1;
    /* Wait for conversion. */
    while(ADCON0bits.NOT_DONE);

    /* Save conversion result. */
    result = ADRESH;
    result <<= 8;
    result |= ADRESL;

    return result;
}

/**
 * Changes the duty cycle of the PWM pulse generated by CCP1.
 * @param duty_cycle the new duty cycle value.
 */
void change_duty_cycle(uint16_t duty_cycle){
    
    /* Write new value on CCP1 to change the PWM's duty cycle. */
    CCP1CONbits.DC1B = (duty_cycle & 0b00000011);
    CCPR1L = ((duty_cycle & 0b1111111100) >> 2);
    
}

/**
 * Interruption routine. Runs every 1 ms.
 */
void interrupt ISR(void){
    
    /* Disable interruptions. */
    INTCONbits.GIE = 0;
    /* Stop TMR1. */
    T1CONbits.TMR1ON = 0;
    /* Read potentiometer. */
    pot_voltage = adc_read();
    /* Change duty cycle value. */
    change_duty_cycle(pot_voltage);
    /* Load value to generate one interruption every 1 ms. */
    TMR1 = 0xF856;
    /* Clear TMR1 interruption flag. */
    PIR1bits.TMR1IF = 0;
    /* Enable interruptions. */
    INTCONbits.GIE = 1;
    /* Start TMR1. */
    T1CONbits.TMR1ON = 1;
    
}
